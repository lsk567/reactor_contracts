module main {
    
    type    * = common.*;
    define  * = common.*;
    const   * = common.*;

    // Trace declaration and axioms
    var trace : trace_t;

    // Display trace in timestamp order
    axiom(forall (i, j : integer) :: (i < j && in_range(i) && in_range(j)) 
        ==> (tag_earlier(g(elem(i)), g(elem(j)))
            || tag_same(g(elem(i)), g(elem(j)))));

    // All microsteps are positive
    axiom(forall (i : integer) :: in_range(i)
        ==> pi2(g(elem(i))) >= 0);

    // NULL events should appear in the suffix
    axiom(forall (j : integer) :: in_range(j) ==> (
        (p1(elem(j)) != NULL) ==> (forall (i : integer) :: in_range(i) ==> 
        ((i < j) ==> p1(elem(i)) != NULL)
    )));

    // All tags should be positive
    axiom(forall (i : integer) :: in_range(i) ==> (
        !tag_earlier(g(elem(i)), zero())
    ));

    // Display simulatenous elements in certain order
    axiom(forall (i, j : integer) :: (in_range(i) && in_range(j)) ==> (
        (tag_same(g(elem(i)), g(elem(j)))
            && p1(elem(i)) == STARTUP
            && p1(elem(j)) == A1)
        ==> i < j
    ));
    axiom(forall (i, j : integer) :: (in_range(i) && in_range(j)) ==> (
        (tag_same(g(elem(i)), g(elem(j)))
            && p1(elem(i)) == A1
            && p1(elem(j)) == A_out)
        ==> i < j
    ));
    axiom(forall (i, j : integer) :: (in_range(i) && in_range(j)) ==> (
        (tag_same(g(elem(i)), g(elem(j)))
            && p1(elem(i)) == A_out
            && p1(elem(j)) == B_in)
        ==> i < j
    ));
    axiom(forall (i, j : integer) :: (in_range(i) && in_range(j)) ==> (
        (tag_same(g(elem(i)), g(elem(j)))
            && p1(elem(i)) == B_in
            && p1(elem(j)) == B1)
        ==> i < j
    ));
    axiom(forall (i, j : integer) :: (in_range(i) && in_range(j)) ==> (
        (tag_same(g(elem(i)), g(elem(j)))
            && p1(elem(i)) == B1
            && p1(elem(j)) == B_out)
        ==> i < j
    ));
    axiom(forall (i, j : integer) :: (in_range(i) && in_range(j)) ==> (
        (tag_same(g(elem(i)), g(elem(j)))
            && p1(elem(i)) == B_out
            && p1(elem(j)) == C_in)
        ==> i < j
    ));
    axiom(forall (i, j : integer) :: (in_range(i) && in_range(j)) ==> (
        (tag_same(g(elem(i)), g(elem(j)))
            && p1(elem(i)) == C_in
            && p1(elem(j)) == C1)
        ==> i < j
    ));
    axiom(forall (i, j : integer) :: (in_range(i) && in_range(j)) ==> (
        (tag_same(g(elem(i)), g(elem(j)))
            && p1(elem(i)) == C1
            && p1(elem(j)) == C_s)
        ==> i < j
    ));

    // STARTUP only appears once.
    axiom(forall (i : integer) :: (p1(elem(i)) == STARTUP && in_range(i))
        ==> !(exists (j : integer) :: p1(elem(j)) == STARTUP
            && i < j));

    // Triggers appear before reactions at the same logical time.
    axiom(forall (j : integer) :: (p1(elem(j)) == A1 && in_range(j))
        ==> (exists (i : integer) :: p1(elem(i)) == STARTUP
            && tag_same(g(elem(i)), g(elem(j)))
            && i < j));
    axiom(forall (j : integer) :: (p1(elem(j)) == B1 && in_range(j))
        ==> (exists (i : integer) :: p1(elem(i)) == B_in
            && tag_same(g(elem(i)), g(elem(j)))
            && i < j));
    axiom(forall (j : integer) :: (p1(elem(j)) == C1 && in_range(j))
        ==> (exists (i : integer) :: p1(elem(i)) == C_in
            && tag_same(g(elem(i)), g(elem(j)))
            && i < j));

    // Element helper that shortens property
    define elem(i : integer) : element_t
    = get(trace, i);

    // Helper predicates
    define phi_0(e : element_t) : boolean
    = p1(e) == STARTUP && tag_same(g(e), zero()); 

    define phi_1(e : element_t) : boolean
    = p1(e) == A1;

    define phi_2p(e : element_t) : boolean
    = true;

    define phi_2q(e : element_t) : boolean
    = exists (_i : integer) :: in_range(_i)
        && p1(elem(_i)) == A_out
        && val(elem(_i)) == true
        && tag_same(g(elem(_i)), g(e));

    define phi_2(e : element_t) : boolean
    = phi_2p(e) ==> phi_2q(e);

    define phi_3(e : element_t) : boolean
    = forall (_i : integer) :: in_range(_i)
        ==> ((
            p1(elem(_i)) == A_out
            && tag_same(g(elem(_i)), g(e))
        ) ==> (
            exists (_j : integer) :: (
                p1(elem(_j)) == B_in
                && val(elem(_i)) == val(elem(_j))
                && tag_same(g(elem(_i)), g(elem(_j)))
            )
        ));

    define phi_4(e : element_t) : boolean
    = p1(e) == B1;

    define phi_5p(e : element_t) : boolean
    = exists (_i : integer) :: in_range(_i)
        && p1(elem(_i)) == B_ramp_exists
        && val(elem(_i)) == true
        && !tag_later(g(elem(_i)), g(e));
    // Contract does not care about ramp.
    // If uncommented, we expect a valid refinement.
    /*
    define phi_5p(e : element_t) : boolean
    = true;
    */

    define phi_5q(e : element_t) : boolean
    = forall (_i : integer) :: in_range(_i)
        ==> ((
            p1(elem(_i)) == B_in
            && tag_same(g(elem(_i)), g(e))
        ) ==> (
            exists (_j : integer) :: (
                p1(elem(_j)) == B_out
                && val(elem(_i)) == val(elem(_j))
                && tag_same(g(elem(_i)), g(elem(_j)))
            )
        ));

    define phi_5(e : element_t) : boolean
    = phi_5p(e) ==> phi_5q(e);

    // Note: elements in the trace already represent "present" values
    define phi_6(e : element_t) : boolean
    = p1(e) == B_in;

    define phi_7(e : element_t) : boolean
    = forall (_i : integer) :: in_range(_i)
        ==> ((
            p1(elem(_i)) == B_out
            && tag_same(g(elem(_i)), g(e))
        ) ==> (
            exists (_j : integer) :: (
                p1(elem(_j)) == C_in
                && val(elem(_i)) == val(elem(_j))
                && tag_same(g(elem(_i)), g(elem(_j)))
            )
        ));

    define phi_8(e : element_t) : boolean
    = p1(e) == C1;

    define phi_9p(e : element_t) : boolean
    = true; 

    define phi_9q(e : element_t) : boolean
    = forall (_i : integer) :: in_range(_i)
        ==> ((
            p1(elem(_i)) == C_in
            && tag_same(g(elem(_i)), g(e))
        ) ==> (
            exists (_j : integer) :: (
                p1(elem(_j)) == C_s
                && val(elem(_i)) == val(elem(_j))
                && tag_same(g(elem(_i)), g(elem(_j)))
            )
        ));

    define phi_9(e : element_t) : boolean
    = phi_9p(e) ==> phi_9q(e);

    define phi_10(e : element_t) : boolean
    = p1(e) == C_in;


    // Contract formulae
    define Sys_spec() : boolean
    = exists (x : integer) :: in_range(x)
        && !tag_earlier(g(elem(x)), zero())
        && p1(elem(x)) == C_s
        && val(elem(x)) == true;

    define Revised_sys_spec() : boolean
    = (!tag_earlier(g(elem(0)), zero())
        && p1(elem(0)) == B_ramp_exists
        && val(elem(0)) == true)
        ==> (
        exists (y : integer) :: in_range(y)
        && !tag_earlier(g(elem(y)), g(elem(0)))
        && p1(elem(y)) == C_s
        && val(elem(y)) == true
        );

    define G1() : boolean
    = exists (v : integer) :: phi_0(elem(v));

    define G2() : boolean
    = forall (_u : integer) :: in_range(_u) ==> 
        (((phi_0(elem(_u))) ==> (exists (_v : integer) ::
            in_range(_v)
            && tag_same(g(elem(_v)), g(elem(_u)))
            && phi_1(elem(_v))
            )) 
        && (phi_1(elem(_u)) ==> phi_2(elem(_u))) 
    );

    define G3() : boolean
    = forall (u : integer) :: in_range(u) ==>
        (phi_3(elem(u)));

    define G4() : boolean
    = forall (_u : integer) :: in_range(_u) ==> 
        (((phi_6(elem(_u))) ==> (exists (_v : integer) ::
            in_range(_v)
            && tag_same(g(elem(_v)), g(elem(_u)))
            && phi_4(elem(_v)))) 
        && (phi_4(elem(_u)) ==> phi_5(elem(_u))) 
    );

    define G5() : boolean
    = forall (u : integer) :: in_range(u) ==>
        (phi_7(elem(u)));

    define G6() : boolean
    = forall (_u : integer) :: in_range(_u) ==> 
        (((phi_10(elem(_u))) ==> (exists (_v : integer) ::
            in_range(_v)
            && tag_same(g(elem(_v)), g(elem(_u)))
            && phi_8(elem(_v)))) 
        && (phi_8(elem(_u)) ==> phi_9(elem(_u))) 
    );

    // Instead of putting guarantees in assume(),
    // put them in implication form.
    // More constrained proposition (system spec) implies
    // less constrained propsition.
    property refine_G : 
    (
        G1() && G2() && G3() && G4() && G5() && G6()
    )
    // ==> Sys_spec();
    ==> Revised_sys_spec(); 

    control {
        v = unroll(0);
        check;
        print_results;
        v.print_cex;
    }
}
