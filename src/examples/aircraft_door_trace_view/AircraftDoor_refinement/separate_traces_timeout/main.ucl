// TODO: 1. Merge all trace types
//       2. Try encoding guarantees using assume()

module main {
    
    type    * = common.*;
    define  * = common.*;
    const   * = common.*;

    define phi_0(e : tagged_event_t) : boolean
    = a(e) == STARTUP && g2(e) == zero(); 

    define phi_1(i : invocation_t) : boolean
    = N(i) == A1;

    define phi_2p(i : invocation_t) : boolean
    = true;

    define phi_2q(i : invocation_t) : boolean
    = in_trace3(trace_A_out, {true, g(i)});

    define phi_2(i : invocation_t) : boolean
    = phi_2p(i) ==> phi_2q(i);

    var trace_startup : trace2_t; 
    var trace_A1 : trace_t;
    var trace_A_out : trace3_t;

    // Instead of putting guarantees in assume(),
    // put them in implication form.
    property refine_G : (
        (forall (v : tagged_event_t) :: in_trace2(trace_startup, v)
            ==> (!(exists (u : tagged_event_t) :: in_trace2(trace_startup, u)
                    && tag_earlier(g2(u), g2(v)))   // This happen before needs to apply to all elements in trace, not just startup.
                <==> phi_0(v)))
        && (forall (u : tagged_event_t) :: in_trace2(trace_startup, u)
            ==> ((phi_0(u) ==> (exists (v : invocation_t) ::
                in_trace(trace_A1, v)
                && tag_earlier(g2(u), g(v)) // Again, need a hb over entire po-trace, not a subset of po-trace.
                && phi_1(v)
                && (phi_1(v) ==> phi_2(v)))) 
                    // && (phi)  // Because u and v have different types, the second implication is merged into the existential clause. We need to unify the type of u and v.
        ))
    ) // Conjunction of contract guarantees
    ==> (exists (x : variable_t) :: in_trace3(trace_A_out, x)
        && tag_earlier(zero(), g3(x)) && v(x) == true);

    control {
        v = unroll(0);
        check;
        print_results;
        v.print_cex;
    }
}
